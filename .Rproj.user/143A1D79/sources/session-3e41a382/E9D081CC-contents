
####### prepare abundance data (with env variables) #######
ma = read.csv("~/XYData/Lobster/MA_obs.csv")
me = read.csv("~/XYData/Lobster/MENH_obs.csv")
fe = read.csv("~/XYData/Lobster/NEFSC_obs.csv")

me[c("Catch_ma", "Catch_fa", "Catch_mj", "Catch_fj")][is.na(me[c("Catch_ma", "Catch_fa", "Catch_mj", "Catch_fj")])] <- 0
ma[c("Catch_ma", "Catch_fa", "Catch_mj", "Catch_fj")][is.na(ma[c("Catch_ma", "Catch_fa", "Catch_mj", "Catch_fj")])] <- 0
fe[c("Catch_ma", "Catch_fa", "Catch_mj", "Catch_fj")][is.na(fe[c("Catch_ma", "Catch_fa", "Catch_mj", "Catch_fj")])] <- 0

# subset for GOM
Data_Set = rbind(ma, me, fe)
Data_Set<-Data_Set[!is.na(Data_Set$Stat_Area),]
# Stat areas for GOM/GBK:
Data_Set = Data_Set[which(Data_Set$Stat_Area %in% 
                            c(464:465, 511:515, 521:526, 541:543, 561:562)),]

#subset for 1990-2020
Data_Set = subset(Data_Set, Data_Set$Year<=2020 & Data_Set$Year >=1990)
Data_Set = Data_Set[Data_Set$Depth > 0,]

#standadize to 22750 sq m, 0.013+0.016+0.024+0.038/4 = 22750
Data_Set$Catch_ma <- (Data_Set$Catch_ma/Data_Set$Area_Swept)*22750
Data_Set$Catch_fa <- (Data_Set$Catch_fa/Data_Set$Area_Swept)*22750
Data_Set$Catch_mj <- (Data_Set$Catch_mj/Data_Set$Area_Swept)*22750
Data_Set$Catch_fj <- (Data_Set$Catch_fj/Data_Set$Area_Swept)*22750

# subset to adult
df = Data_Set
df$abundance = df$Catch_fa + df$Catch_ma

df <- df %>%
  mutate(Season = case_when(
    Month %in% 9:10 ~ "Fall",
    Month %in% 4:6  ~ "Spring",
    TRUE            ~ "Other"   
  ))


df= df %>%
  select(Year, Season, Latitude, Longitude, Depth, oisst_c, abundance)
colnames(df)=c("Year", "Season", "Latitude", "Longitude", "Depth", "SST", "abundance")

df_clean <- df[complete.cases(df), ]
Lobster_SI_9020=df_clean
save(Lobster_SI_9020, file = "Lobster_SI_9020.Rdata")

####### SI curves function #######
#surveydata should contain abundance and envVaribale for SI, provide df as an example/project deliverable input
#envVariable= c("Latitude","Longitude","Depth", "SST")

# can do it for all seasons that defined by user

SIcurve <- function(surveydata, envVariable, Seasons,int_n){  
  library(classInt)
  library(mgcv)
  
  results <- list() 
  
  for (Season in Seasons){
    # subset seasons
    Data_Set <- surveydata[surveydata$Season == Season, ]
    
    si.df.bins <- list()
    si.df.SI <- list()
    si.df.breaks <- list()
    
    # build SI curves
    for (i in seq_along(envVariable)){
      envData <- as.numeric(as.character(Data_Set[[envVariable[i]]]))
      envData <- na.omit(envData)
      
      if (length(envData) < int_n + 1){
        warning(paste("Not enough data for", envVariable[i], "in", Season, "season, skip."))
        next
      }
      
      envData_int <- classIntervals(envData, int_n, style = "fisher", largeN = nrow(Data_Set))
      envData_int[[2]][1] <- envData_int[[2]][1] - 0.1
      
      Data_Set$envData_bins <- cut(envData, breaks = envData_int$brks)
      
      SI <- aggregate(Data_Set$abundance ~ envData_bins, data = Data_Set, FUN = "mean")
      colnames(SI)[1] <- paste0(envVariable[i], "_bins")
      colnames(SI)[2] <- "abundance"
      
      SI$SI_value <- (SI$abundance - min(SI$abundance)) / (max(SI$abundance) - min(SI$abundance))
      SI$bin <- 1:nrow(SI)
      
      if (nrow(SI) > 3){ 
        g <- gam(abundance ~ s(bin), data = SI)
        SI$abundance <- predict(g, newdata = SI, type = "response")
        SI$SI_value <- (SI$abundance - min(SI$abundance)) / (max(SI$abundance) - min(SI$abundance))
      }
      
      plot(SI[[1]], SI$SI_value, pch = int_n, main = paste(envVariable[i], Season))
      
      si.df.bins[[ paste(envVariable[i], Season, sep="_") ]] <- SI[[1]]
      si.df.SI[[   paste(envVariable[i], Season, sep="_") ]] <- SI$SI_value
      si.df.breaks[[paste(envVariable[i], Season, sep="_") ]] <-envData_int$brks
    }
    
    results[[Season]] <- list(bins = si.df.bins, 
                              SI = si.df.SI,
                              breaks =si.df.breaks)
  }
  
  return(results)
}


# can only plot Spring and Fall
get_midpoints <- function(bin_factor){
  bins <- as.character(bin_factor)
  splits <- strsplit(bins, "\\(|,|\\]")
  mids <- sapply(splits, function(x){
    mean(as.numeric(x[2:3]))
  })
  return(mids)
}
plot_SI_curves <- function(surveydata, envVariable, Seasons,int_n, 
                           filename){
  SIData=SIcurve(surveydata, 
                 envVariable, 
                 Seasons,
                 int_n)
  
  jpeg(filename, res = 600, units = "in", width = 4, height = 3*length(envVariable))
  par(mfrow=c(length(envVariable),1))
  
  for (var in envVariable){
    spring_bins <- SIData$Spring$bins[[paste0(var,"_Spring")]]
    spring_mid  <- get_midpoints(spring_bins)
    spring_SI   <- SIData$Spring$SI[[paste0(var,"_Spring")]]
    
    fall_bins <- SIData$Fall$bins[[paste0(var,"_Fall")]]
    fall_mid  <- get_midpoints(fall_bins)
    fall_SI   <- SIData$Fall$SI[[paste0(var,"_Fall")]]
    
    plot(spring_mid, spring_SI, type="l", col="blue", lwd=3, 
         xlab=var, ylab="SI", main=var,
         ylim=c(0,1),
         xlim=c(min(c(spring_mid, fall_mid)), max(c(spring_mid, fall_mid))+1.5)
    )
    lines(fall_mid, fall_SI, col="red", lwd=3)
    
    legend("topright", legend=c("Spring","Fall"), col=c("blue","red"), 
           lwd=3, bty="n")
  }
  dev.off()
}


# examples of using functions
SIData=SIcurve(surveydata = Lobster_SI_9020, 
            envVariable = c("Latitude","Longitude","Depth", "SST"), 
            int_n = 20, 
            Seasons =c("Spring","Fall"))

plots=plot_SI_curves(surveydata = Lobster_SI_9020,
                     envVariable = c("Latitude","Longitude","Depth", "SST"),
                     int_n = 20, 
                     Seasons =c("Spring","Fall"),
                     filename = "SI_curvrs.jpg")

####### prepare temperature mapping data #######
library(dplyr)
library(raster)
oisst_c<-read.csv("~/XYData/Lobster/OISST_C_nes_9023.csv") # dataset for mapping
depth_raster <- raster("~/XYData/Lobster/NAS.asc")

all_seasons <- data.frame()

for (Season in c("SP", "FA")) {
  if (Season == "SP") {
    oisst_season <- filter(oisst_c, season == "spring")
    season_name <- "Spring"
  } else {
    oisst_season <- filter(oisst_c, season == "fall")
    season_name <- "Fall"
  }
  avg_temp <- oisst_season %>%
    group_by(lon, lat) %>%            
    summarise(Temp = mean(season.mean, na.rm = TRUE)) %>%
    ungroup() #averaged by year
  
  avg_temp <- avg_temp %>%
    filter(lon > -71, lon < -65, lat > 39.5, lat < 44.99)
  
  latlon <- avg_temp[, c("lon", "lat")]
  avg_temp$Depth <- raster::extract(depth_raster, latlon) * -1
  
  avg_temp$Season <- season_name
  
  ts_season <- avg_temp %>%
    rename(Latitude = lat,
           Longitude = lon,
           SST = Temp)
  all_seasons <- bind_rows(all_seasons, ts_season)
}

map_data <- all_seasons

map_data = map_data[which(map_data$Depth > 0),]

LobsterHSI_mapData= map_data

save(LobsterHSI_mapData, file = "LobsterHSI_mapData.Rdata")

LobsterHSI_monthData <- LobsterHSI_mapData %>%
  mutate(Month = case_when(
    Season == "Spring" ~ 4,
    Season == "Fall"   ~ 9,
    TRUE               ~ NA_real_
  ))

LobsterHSI_monthData <- subset(LobsterHSI_monthData, select = -Season)

save(LobsterHSI_monthData, file = "LobsterHSI_monthData.Rdata")

####### HSI mapping function #######

get_HSI <- function(surveydata, MapData, envVariable, Seasons, int_n, weights) {
  
  SIData=SIcurve(surveydata, 
                 envVariable, 
                 Seasons,
                 int_n)
  
  MapData_out <- MapData
  
  for (Season in Seasons) {
    for (var in envVariable) {
      
      name <- paste0(var, "_", Season)
      
      bins   <- SIData[[Season]]$bins[[name]]
      si     <- SIData[[Season]]$SI[[name]]
      breaks <- SIData[[Season]]$breaks[[name]]
      
      # change the boundaries of breaks to include all data
      breaks[1] <- min(MapData_out[[var]], na.rm = TRUE) - 1
      breaks[length(breaks)] <- max(MapData_out[[var]], na.rm = TRUE) + 1
      
      lookup <- data.frame(
        bin = levels(bins),
        si  = si
      )
      
      #create colume
      col_name <- paste0(var, "_si")
      if (!col_name %in% names(MapData_out)) {
        MapData_out[[col_name]] <- NA_real_
      }
      
      #subset season
      idx <- MapData_out$Season == Season
      MapData_out[[col_name]][idx] <- lookup$si[
        as.numeric(cut(MapData_out[[var]][idx], breaks = breaks, include.lowest = TRUE))
      ]
    }
  }
  MapData_out <- MapData_out[complete.cases(MapData_out), ]
  
  #Weighted HSI
  MapData_out$AMM_HSI <- rowSums(
    sapply(seq_along(envVariable), function(i) {
      MapData_out[[paste0(envVariable[i], "_si")]] * weights[i]
    }),
    na.rm = TRUE
  )
  
  MapData_out = MapData_out[,c("Season","Latitude", "Longitude", "AMM_HSI")] 
  
  return(MapData_out)
}

HSImap <- function(surveydata, MapData, envVariable, Seasons, int_n, weights, filename) {
  
  HSI = get_HSI(surveydata, MapData,envVariable, Seasons, int_n, weights)
  
  library(sp)
  library(gstat)
  library(rworldmap)
  library(rworldxtra)
  library(colorRamps)
  library(gridExtra); data("countriesHigh")
  library(automap)
  
  
  map_list <- list()
  
  for (Season in Seasons) {
    Map_data <- HSI[HSI$Season == Season, ]
    ts <- Map_data[,c("Longitude","Latitude","AMM_HSI")]
    coordinates(ts) = ~Longitude + Latitude

    auto = autofitVariogram(AMM_HSI ~ 1, ts)
    g = gstat(formula = AMM_HSI ~ 1, model = auto$var_model, data = ts, maxdist = 0.2)

    xrange = range(ts$Longitude)
    yrange = range(ts$Latitude)
    grid = expand.grid(Longitude = seq(from = xrange[1], to = xrange[2], by = 0.01), 
                       Latitude = seq(from = yrange[1], to = yrange[2], by = 0.01))
    gridded(grid) = ~Longitude + Latitude
    
    p = predict(g, newdata = grid)
    proj4string(p) <- "+proj=longlat"

    col = colorRamps::matlab.like(100)
    map_list[[Season]] <- spplot(
      p, 
      sp.layout = list(list("sp.polygons", countriesHigh, first = FALSE, lwd = 0.1, fill="grey")),
      at = (0:100)/100, # HSI scale 0-1
      par.settings = list(fontsize = list(text = 12)),
      col.regions = col,
      zcol = "var1.pred",
      main = list(label=Season),
      scales=list(draw=TRUE),
      xlab="", ylab="", colorkey=TRUE
    )
  }
  
  jpeg(filename, res = 300, units = "in", width = 6*length(Seasons), height = 6)
  grid.arrange(grobs = map_list, ncol = length(Seasons))  
  dev.off()
  
}


# for project users, define months 1-6 as spring, define months 7-12 as fall
LobsterHSI_mapData <- LobsterHSI_monthData %>%
  dplyr::mutate(Season = case_when(
    Month %in% c(1:6) ~ "Spring",
    Month %in% c(7:12)   ~ "Fall",
    TRUE               ~ NA_character_))%>%
  dplyr::select(-Month)


HSI <- get_HSI(surveydata = Lobster_SI_9020, 
               MapData = LobsterHSI_mapData,
               envVariable = c("Latitude","Longitude","Depth", "SST"), 
               int_n = 20, 
               Seasons =c("Spring","Fall"),
               weights=c(0.25,0.25,0.25,0.25))



HSImap=HSImap(surveydata = Lobster_SI_9020, 
        MapData = LobsterHSI_mapData,
        envVariable = c("Latitude","Longitude","Depth", "SST"), 
        Seasons =c("Spring","Fall"),
        int_n = 20, 
        weights=c(0.25,0.25,0.25,0.25), 
        filename="HSIplot.jpg")





